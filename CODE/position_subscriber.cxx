/* position_subscriber.cxx

   A subscription example

   This file is derived from code automatically generated by the rtiddsgen
   command:

   rtiddsgen -language C++ -example <arch> position.idl

   Example subscription of type Position automatically generated by
   'rtiddsgen'. To test them follow these steps:

   (1) Compile this file and the example publication.

   (2) Start the subscription with the command
       objs/<arch>/position_subscriber <domain_id> <sample_count>

   (3) Start the publication with the command
       objs/<arch>/position_publisher <domain_id> <sample_count>

   (4) [Optional] Specify the list of discovery initial peers and
       multicast receive addresses via an environment variable or a file
       (in the current working directory) called NDDS_DISCOVERY_PEERS.

   You can run any number of publishers and subscribers programs, and can
   add and remove them dynamically from the domain.


   Example:

       To run the example application on domain <domain_id>:

       On Unix:

       objs/<arch>/position_publisher <domain_id>
       objs/<arch>/position_subscriber <domain_id>

       On Windows:

       objs\<arch>\position_publisher <domain_id>
       objs\<arch>\position_subscriber <domain_id>


modification history
------------ -------
*/

#include "position_subscriber.h"

class PositionListener : public DDSDataReaderListener {
  public:
    virtual void on_requested_deadline_missed(
        DDSDataReader* /*reader*/,
        const DDS_RequestedDeadlineMissedStatus& /*status*/) {}

    virtual void on_requested_incompatible_qos(
        DDSDataReader* /*reader*/,
        const DDS_RequestedIncompatibleQosStatus& /*status*/) {}

    virtual void on_sample_rejected(
        DDSDataReader* /*reader*/,
        const DDS_SampleRejectedStatus& /*status*/) {}

    virtual void on_liveliness_changed(
        DDSDataReader* /*reader*/,
        const DDS_LivelinessChangedStatus& /*status*/) {}

    virtual void on_sample_lost(
        DDSDataReader* /*reader*/,
        const DDS_SampleLostStatus& /*status*/) {}

    virtual void on_subscription_matched(
        DDSDataReader* /*reader*/,
        const DDS_SubscriptionMatchedStatus& /*status*/) {}

    virtual void on_data_available(DDSDataReader* reader);
};


void PositionListener::on_data_available(DDSDataReader* reader)
{
    PositionDataReader *Position_reader = NULL;
    PositionSeq data_seq;
    DDS_SampleInfoSeq info_seq;
    DDS_ReturnCode_t retcode;
    int left_stop;
    int i;

    Position_reader = PositionDataReader::narrow(reader);
    if (Position_reader == NULL) {
        printf("DataReader narrow error\n");
        return;
    }

    retcode = Position_reader->take(
        data_seq, info_seq, DDS_LENGTH_UNLIMITED,
        DDS_ANY_SAMPLE_STATE, DDS_ANY_VIEW_STATE, DDS_ANY_INSTANCE_STATE);

    if (retcode == DDS_RETCODE_NO_DATA) {
        return;
    } else if (retcode != DDS_RETCODE_OK) {
        printf("take error %d\n", retcode);
        return;
    }
    for (i = 0; i < data_seq.length(); ++i) {
        if (info_seq[i].valid_data) {
            //PositionTypeSupport::print_data(&data_seq[i]);
            n_stops = data_seq[i].numStops;
            if(user_o==0)   //for operator
            {
              printf("Position\t%10s\t%5s\t%6s\t%5d\t%5d\t%5.2lf\t%5d\t", data_seq[i].route, data_seq[i].vehicle, data_seq[i].trafficConditions, data_seq[i].stopNumber,data_seq[i].numStops,(double)data_seq[i].timeBetweenStops,data_seq[i].fillInRatio);
              printf("%5s\n", data_seq[i].timestamp);
            }
            else  //not operator
            {
                if(finish == 1)
                {
                    if(on_bus == 0)   //on bus
                    {
                        if( (strcmp(currentbus,data_seq[i].vehicle)==0) && (strcmp(data_seq[i].route, route)==0 ))
                        {
                            if(end_stop==data_seq[i].stopNumber)
                            {
                                printf("Arriving at destination by %s at %s\n",data_seq[i].vehicle, data_seq[i].timestamp);
                                finish = 0;
                                on_bus = 1;  //get down the bus
                            }
                            else
                            {
                                if(end_stop > data_seq[i].stopNumber)
                                {
                                    left_stop = end_stop - data_seq[i].stopNumber;
                                }
                                else
                                {
                                    left_stop = data_seq[i].numStops- data_seq[i].stopNumber +end_stop;
                                }
                                if(accident_stop == 0)
                                {
                                    printf("Arriving at stop #%d, at %s, %s, %d stops left\n", data_seq[i].stopNumber, data_seq[i].timestamp, data_seq[i].trafficConditions, left_stop);
                                }
                                else if (accident_stop == data_seq[i].stopNumber)
                                {
                                    printf("Arriving at stop #%d, at %s, %s, accident, %d stops left\n", data_seq[i].stopNumber, data_seq[i].timestamp, data_seq[i].trafficConditions, left_stop);
                                    accident_stop = 0;
                                }
                            }
                        }
                    }
                    else  //(on_bus== 1)  not on bus
                    {
                        if( (strcmp(data_seq[i].route, route)==0 ) && (data_seq[i].stopNumber == start_stop))
                        {
                            if(end_stop > data_seq[i].stopNumber)
                            {
                                left_stop = end_stop - data_seq[i].stopNumber;
                            }
                            else
                            {
                                left_stop = data_seq[i].numStops- data_seq[i].stopNumber +end_stop;
                            }
                            printf("Geting on %s at %s, %s, %d stops left\n",data_seq[i].vehicle ,data_seq[i].timestamp, data_seq[i].trafficConditions, left_stop);
                            strcpy(currentbus ,data_seq[i].vehicle);
                            on_bus=0;
                        }
                    }
                }
            }
        }
    }

    retcode = Position_reader->return_loan(data_seq, info_seq);
    if (retcode != DDS_RETCODE_OK) {
        printf("return loan error %d\n", retcode);
    }
}


/* Delete all entities */
static int subscriber_shutdown(
    DDSDomainParticipant *participant)
{
    DDS_ReturnCode_t retcode;
    int status = 0;

    if (participant != NULL) {
        retcode = participant->delete_contained_entities();
        if (retcode != DDS_RETCODE_OK) {
            printf("delete_contained_entities error %d\n", retcode);
            status = -1;
        }

        retcode = DDSTheParticipantFactory->delete_participant(participant);
        if (retcode != DDS_RETCODE_OK) {
            printf("delete_participant error %d\n", retcode);
            status = -1;
        }
    }

    /* RTI Connext provides the finalize_instance() method on
       domain participant factory for people who want to release memory used
       by the participant factory. Uncomment the following block of code for
       clean destruction of the singleton. */
/*
    retcode = DDSDomainParticipantFactory::finalize_instance();
    if (retcode != DDS_RETCODE_OK) {
        printf("finalize_instance error %d\n", retcode);
        status = -1;
    }
*/
    return status;
}

int subscriber_main(int domainId, int sample_count, char *user)
{
    DDSDomainParticipant *participant = NULL;
    DDSSubscriber *subscriber = NULL;
    DDS_ReturnCode_t retcode;

    DDSTopic *topic = NULL;
    PositionListener *reader_listener = NULL;
    DDSDataReader *reader = NULL;
    const char *type_name = NULL;

    DDSTopic *accident_topic = NULL;
    AccidentListener *accident_reader_listener = NULL;
    DDSDataReader *accident_reader = NULL;
    const char *accident_type_name = NULL;

    int count = 0;
    DDS_Duration_t receive_period = {1,0};
    int status = 0;

    /* To customize the participant QoS, use
       the configuration file USER_QOS_PROFILES.xml */
    participant = DDSTheParticipantFactory->create_participant(
        0, DDS_PARTICIPANT_QOS_DEFAULT,
        NULL /* listener */, DDS_STATUS_MASK_NONE);
    if (participant == NULL) {
        printf("create_participant error\n");
        subscriber_shutdown(participant);
        return -1;
    }

    /* To customize the subscriber QoS, use
       the configuration file USER_QOS_PROFILES.xml */
    subscriber = participant->create_subscriber(
        DDS_SUBSCRIBER_QOS_DEFAULT, NULL /* listener */, DDS_STATUS_MASK_NONE);
    if (subscriber == NULL) {
        printf("create_subscriber error\n");
        subscriber_shutdown(participant);
        return -1;
    }

    //accident
    /* Register the type before creating the topic */
    accident_type_name = AccidentTypeSupport::get_type_name();
    retcode = AccidentTypeSupport::register_type(
        participant, accident_type_name);
    if (retcode != DDS_RETCODE_OK) {
        printf("register_type error %d\n", retcode);
        subscriber_shutdown(participant);
        return -1;
    }

    type_name = PositionTypeSupport::get_type_name();
    retcode = PositionTypeSupport::register_type(
        participant, type_name);
    if (retcode != DDS_RETCODE_OK) {
        printf("register_type error %d\n", retcode);
        subscriber_shutdown(participant);

        return -1;
    }

    /* To customize the topic QoS, use
       the configuration file USER_QOS_PROFILES.xml */
    accident_topic = participant->create_topic(
        "Accident",
        accident_type_name, DDS_TOPIC_QOS_DEFAULT, NULL /* listener */,
        DDS_STATUS_MASK_NONE);
    if (accident_topic == NULL) {
        printf("create_topic error\n");
        subscriber_shutdown(participant);
        return -1;
    }


    topic = participant->create_topic(
        "Position",
        type_name, DDS_TOPIC_QOS_DEFAULT, NULL /* listener */,
        DDS_STATUS_MASK_NONE);
    if (topic == NULL) {
        printf("create_topic error\n");
        subscriber_shutdown(participant);
        return -1;
    }

    /* Create a data reader listener */
    accident_reader_listener = new AccidentListener();
    reader_listener = new PositionListener();


    /* To customize the data reader QoS, use
       the configuration file USER_QOS_PROFILES.xml */
    accident_reader = subscriber->create_datareader(
        accident_topic, DDS_DATAREADER_QOS_DEFAULT, accident_reader_listener,
        DDS_STATUS_MASK_ALL);
    if (accident_reader == NULL) {
        printf("create_datareader error\n");
        subscriber_shutdown(participant);
        delete accident_reader_listener;
        return -1;
    }

    reader = subscriber->create_datareader(
        topic, DDS_DATAREADER_QOS_DEFAULT, reader_listener,
        DDS_STATUS_MASK_ALL);
    if (reader == NULL) {
        printf("create_datareader error\n");
        subscriber_shutdown(participant);
        delete reader_listener;
        return -1;
    }


    /* Main loop */

    if (user_o==0)  //opeartor
    {
         //Position s3 route(10) s5 bus(5) s5 traffic(6) s2 location(5) s4 numstops(5) s12 stoptime(5) s7 ratio(5) s5 time
         printf("MessageType\tRoute\tVehicle\tTraffic\tStop#\t#Stops\tTimeBetweenStops\tFill%\tTimestamp\n");


         for (count=0; (sample_count == 0) || (count < sample_count); ++count) {
            //printf("Position subscriber sleeping for %d sec...\n",receive_period.sec);


            NDDSUtility::sleep(receive_period);

        }
    }

    else   //passenger
    {
        printf("waiting for the bus...\n");
        while(finish==1)
        {
            if(on_bus==0)   //on the bus
            {
                //listen message for busxx
                for (count=0; (sample_count == 0) || (count < sample_count); ++count)
                {
                    //printf("Position subscriber sleeping for %d sec...\n", receive_period.sec);
                    if(on_bus==1)
                    {
                        break;
                    }
                    if(loop_over==0)
                    {
                        break;    //exit loop
                    }
                    NDDSUtility::sleep(receive_period);
                }

            }
            else  //waiting for bus:not on bus
            {
                //listen position message for stop xx
                for (count=0; (sample_count == 0) || (count < sample_count); ++count)
                {
                    //printf("Position subscriber sleeping for %d sec...\n", receive_period.sec);
                    if(on_bus==0)
                    {
                        break;
                    }
                    NDDSUtility::sleep(receive_period);
                }

            }

        } //end of while

    } //end of if-else(passenger)


    /* Delete all entities */
    status = subscriber_shutdown(participant);

    delete reader_listener;
    delete accident_reader_listener;
    return status;
}


int main(int argc, char *argv[])
{
    int domainId = 0;
    int sample_count = 0; /* infinite loop */

    char user[15];

    //initail
    start_stop=0;
    end_stop=0;
    strcpy(user,"operator");
    strcpy(route,"all");
    
   //printf("user: %s, route: %s, start: %d, stop: %d\n", argv[1], argv[2], atoi(argv[3]), atoi(argv[4]));

    if (argc >= 5) {
        //1: user   2: route   3: start_stop  4: end_stop
        strcpy(user,argv[1]);
        strcpy(route,argv[2]);
        start_stop = atoi(argv[3]);
        end_stop = atoi(argv[4]);
    }

    if(strcmp(user,"operator")==0)
    {
        user_o = 0;    // user is operator
    }
    else
    {
        if(start_stop==end_stop)
        {
            return 0;
        }
        user_o = 1;    // user is not operator
        on_bus = 1;    // wait for bus
    }

    /* Uncomment this to turn on additional logging
    NDDSConfigLogger::get_instance()->
        set_verbosity_by_category(NDDS_CONFIG_LOG_CATEGORY_API,
                                  NDDS_CONFIG_LOG_VERBOSITY_STATUS_ALL);
    */

    return subscriber_main(domainId, sample_count, user);
}


