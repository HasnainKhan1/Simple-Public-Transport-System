/* accident_subscriber.cxx

   A subscription example

   This file is derived from code automatically generated by the rtiddsgen
   command:

   rtiddsgen -language C++ -example <arch> accident.idl

   Example subscription of type Accident automatically generated by
   'rtiddsgen'. To test them follow these steps:

   (1) Compile this file and the example publication.

   (2) Start the subscription with the command
       objs/<arch>/accident_subscriber <domain_id> <sample_count>

   (3) Start the publication with the command
       objs/<arch>/accident_publisher <domain_id> <sample_count>

   (4) [Optional] Specify the list of discovery initial peers and
       multicast receive addresses via an environment variable or a file
       (in the current working directory) called NDDS_DISCOVERY_PEERS.

   You can run any number of publishers and subscribers programs, and can
   add and remove them dynamically from the domain.


   Example:

       To run the example application on domain <domain_id>:

       On Unix:

       objs/<arch>/accident_publisher <domain_id>
       objs/<arch>/accident_subscriber <domain_id>

       On Windows:

       objs\<arch>\accident_publisher <domain_id>
       objs\<arch>\accident_subscriber <domain_id>


modification history
------------ -------
*/

#include "accident_subscriber.h"


int user_o;  //user_o = 0 if it is operator; else = 1
int on_bus;  // 0 = on_bus,  1 = wait for bus
int loop_over;  // 0= arrive destination
int finish;     //check whether go to destination
char route[10];
char currentbus[6];
int start_stop,end_stop;
int accident_stop; // if  accident happen, then set accident_stop to stop number ;no accident will be 0
int debug;  //debug = 0 to show debug message
int n_stops;

void AccidentListener::on_data_available(DDSDataReader* reader)
{
    AccidentDataReader *Accident_reader = NULL;
    AccidentSeq data_seq;
    DDS_SampleInfoSeq info_seq;
    DDS_ReturnCode_t retcode;
    int i;

    Accident_reader = AccidentDataReader::narrow(reader);
    if (Accident_reader == NULL) {
        printf("DataReader narrow error\n");
        return;
    }

    retcode = Accident_reader->take(
        data_seq, info_seq, DDS_LENGTH_UNLIMITED,
        DDS_ANY_SAMPLE_STATE, DDS_ANY_VIEW_STATE, DDS_ANY_INSTANCE_STATE);

    if (retcode == DDS_RETCODE_NO_DATA) {
        return;
    } else if (retcode != DDS_RETCODE_OK) {
        printf("take error %d\n", retcode);
        return;
    }

    for (i = 0; i < data_seq.length(); ++i) {
        if (info_seq[i].valid_data) {
            //AccidentTypeSupport::print_data(&data_seq[i]);
            if(user_o==0)
            {
                //accident s3 route(10) s5 bus(5) s13 location(5) s41 time(5)
                printf("Accident\t%10s\t%5s\t\t\t\t\t%5d\t%5s\n", data_seq[i].route,data_seq[i].vehicle, data_seq[i].stopNumber, data_seq[i].timestamp);
            }

            else  //passenger
            {
                if(finish == 1)
                {
                    if (on_bus==0)
                    {
                        if((strcmp(route,data_seq[i].route)==0 )&& (strcmp(currentbus, data_seq[i].vehicle)==0  ))
                        {
                            accident_stop= data_seq[i].stopNumber;
                        }

                    }
                }
            }

        }
    }

    retcode = Accident_reader->return_loan(data_seq, info_seq);
    if (retcode != DDS_RETCODE_OK) {
        printf("return loan error %d\n", retcode);
    }
}


